buildscript {
    repositories {
        mavenCentral()
        maven {
            url "https://github.com/uio-bmi/crypt4gh/raw/maven"
        }
    }

    dependencies {
        classpath "org.bouncycastle:bcpg-jdk15on:1.59"
        classpath "org.bouncycastle:bcpkix-jdk15on:1.59"
        classpath "commons-io:commons-io:2.5"
        classpath "commons-codec:commons-codec:1.11"
        classpath "com.hierynomus:sshj:0.22.0"
        classpath "no.uio.ifi:crypt4gh:1.0.0"
    }
}

task initBouncyCastle() {
    Security.addProvider(new BouncyCastleProvider())
}

task clean() {
    dependsOn ":cega:clearCEGAConfiguration", ":lega:clearLEGAConfiguration"
    doLast {
        new File(".tmp").deleteDir()
    }
}

task bootstrap() {
    dependsOn ":cega:createCEGAConfiguration", ":lega:createLEGAConfiguration"
}

task deploy() {
    dependsOn ":cega:deployCEGAStack", ":lega:deployLEGAStack"
}

task rm() {
    doLast {
        exec {
            executable "docker"
            args "stack", "rm", "lega"
        }
        sleep 10000
        exec {
            executable "docker"
            args "stack", "rm", "cega"
        }
    }
}

task ls() {
    doLast {
        exec {
            executable "docker"
            args "service", "list"
        }
    }
}

task file {
    doLast {
        mkdir ".tmp"
        File rawFile = new File(".tmp/data.raw")
        RandomAccessFile randomAccessFile = new RandomAccessFile(rawFile, "rw")
        randomAccessFile.setLength(1024 * 1024 * 10)
        randomAccessFile.close()
    }
}

task encrypt() {
    dependsOn file

    doLast {
        File rawFile = new File(".tmp/data.raw")
        File encryptedFile = new File(".tmp/data.raw.enc")
        byte[] digest = DigestUtils.sha256(FileUtils.openInputStream(rawFile))
        String key = FileUtils.readFileToString(new File("lega/.tmp/pgp/ega.pub"), Charset.defaultCharset())
        FileOutputStream fileOutputStream = new FileOutputStream(encryptedFile)
        Crypt4GHOutputStream crypt4GHOutputStream = new Crypt4GHOutputStream(fileOutputStream, key, digest)
        FileUtils.copyFile(rawFile, crypt4GHOutputStream)
        crypt4GHOutputStream.close()
    }
}

task upload() {
    dependsOn encrypt

    doLast {
        SSHClient ssh = new SSHClient()
        ssh.addHostKeyVerifier(new PromiscuousVerifier())
        ssh.connect("localhost", 2222)
        ssh.authPublickey("john", "cega/.tmp/users/john.sec")
        SFTPClient client = ssh.newSFTPClient()
        client.put(".tmp/data.raw.enc", "data.raw.enc")
    }
}


import net.schmizz.sshj.SSHClient
import net.schmizz.sshj.sftp.SFTPClient
import net.schmizz.sshj.transport.verification.PromiscuousVerifier
import no.ifi.uio.crypt4gh.stream.Crypt4GHOutputStream
import org.apache.commons.codec.digest.DigestUtils
import org.apache.commons.io.FileUtils
import org.bouncycastle.bcpg.ArmoredOutputStream
import org.bouncycastle.bcpg.HashAlgorithmTags
import org.bouncycastle.bcpg.sig.Features
import org.bouncycastle.bcpg.sig.KeyFlags
import org.bouncycastle.crypto.generators.RSAKeyPairGenerator
import org.bouncycastle.crypto.params.RSAKeyGenerationParameters
import org.bouncycastle.jce.provider.BouncyCastleProvider
import org.bouncycastle.openpgp.*
import org.bouncycastle.openpgp.operator.PBESecretKeyEncryptor
import org.bouncycastle.openpgp.operator.PGPDigestCalculator
import org.bouncycastle.openpgp.operator.bc.BcPBESecretKeyEncryptorBuilder
import org.bouncycastle.openpgp.operator.bc.BcPGPContentSignerBuilder
import org.bouncycastle.openpgp.operator.bc.BcPGPDigestCalculatorProvider
import org.bouncycastle.openpgp.operator.bc.BcPGPKeyPair
import org.bouncycastle.openssl.jcajce.JcaPEMWriter

import java.nio.charset.Charset
import java.nio.file.Files
import java.nio.file.attribute.PosixFilePermission
import java.security.KeyPair
import java.security.KeyPairGenerator
import java.security.SecureRandom
import java.security.Security

def generateRSAKeyPair() {
    KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance("RSA", "BC")
    keyPairGenerator.initialize(2048, new SecureRandom())
    keyPairGenerator.genKeyPair()
}

def createPGPKeyRingGenerator(String userId, char[] passphrase) throws Exception {
    RSAKeyPairGenerator keyPairGenerator = new RSAKeyPairGenerator()

    keyPairGenerator.init(
            new RSAKeyGenerationParameters(
                    BigInteger.valueOf(0x10001),
                    new SecureRandom(),
                    1024,
                    12
            )
    )

    PGPKeyPair rsaKeyPairSign = new BcPGPKeyPair(
            PGPPublicKey.RSA_SIGN,
            keyPairGenerator.generateKeyPair(),
            new Date()
    )

    PGPKeyPair rsaKeyPairEncrypt = new BcPGPKeyPair(
            PGPPublicKey.RSA_ENCRYPT,
            keyPairGenerator.generateKeyPair(),
            new Date()
    )

    PGPSignatureSubpacketGenerator signHashGenerator = new PGPSignatureSubpacketGenerator()
    signHashGenerator.setKeyFlags(false, KeyFlags.SIGN_DATA | KeyFlags.CERTIFY_OTHER)
    signHashGenerator.setFeature(false, Features.FEATURE_MODIFICATION_DETECTION)

    PGPSignatureSubpacketGenerator encryptHashGenerator = new PGPSignatureSubpacketGenerator()
    encryptHashGenerator.setKeyFlags(false, KeyFlags.ENCRYPT_COMMS | KeyFlags.ENCRYPT_STORAGE)

    PGPDigestCalculator sha1DigestCalculator = new BcPGPDigestCalculatorProvider().get(HashAlgorithmTags.SHA1)
    PGPDigestCalculator sha512DigestCalculator = new BcPGPDigestCalculatorProvider().get(HashAlgorithmTags.SHA512)

    PBESecretKeyEncryptor secretKeyEncryptor = (
            new BcPBESecretKeyEncryptorBuilder(PGPEncryptedData.AES_256, sha512DigestCalculator)
    ).build(passphrase)

    PGPKeyRingGenerator keyRingGen = new PGPKeyRingGenerator(
            PGPSignature.NO_CERTIFICATION,
            rsaKeyPairSign,
            userId,
            sha1DigestCalculator,
            signHashGenerator.generate(),
            null,
            new BcPGPContentSignerBuilder(rsaKeyPairSign.getPublicKey().getAlgorithm(), HashAlgorithmTags.SHA512),
            secretKeyEncryptor
    )

    keyRingGen.addSubKey(rsaKeyPairEncrypt, encryptHashGenerator.generate(), null)

    return keyRingGen
}

def armorByteArray(byte[] data) {
    ByteArrayOutputStream encOut = new ByteArrayOutputStream()
    ArmoredOutputStream armorOut = new ArmoredOutputStream(encOut)
    armorOut.write(data)
    armorOut.flush()
    armorOut.close()
    encOut.toByteArray()
}

def writePublicKey(KeyPair keyPair, String path) {
    File file = new File(path)
    FileWriter fileWriter = new FileWriter(file)
    JcaPEMWriter pemWriter = new JcaPEMWriter(fileWriter)
    pemWriter.writeObject(keyPair.public)
    pemWriter.close()
    Set<PosixFilePermission> perms = new HashSet<>()
    perms.add(PosixFilePermission.OWNER_READ)
    Files.setPosixFilePermissions(file.toPath(), perms)
}

def writePrivateKey(KeyPair keyPair, String path) {
    File file = new File(path)
    FileWriter fileWriter = new FileWriter(file)
    JcaPEMWriter pemWriter = new JcaPEMWriter(fileWriter)
    pemWriter.writeObject(keyPair.private)
    pemWriter.close()
    Set<PosixFilePermission> perms = new HashSet<>()
    perms.add(PosixFilePermission.OWNER_READ)
    Files.setPosixFilePermissions(file.toPath(), perms)
}
