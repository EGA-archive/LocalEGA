buildscript {
    repositories {
        mavenCentral()
    }

    dependencies {
        classpath 'org.bouncycastle:bcpg-jdk15on:1.59'
        classpath 'org.bouncycastle:bcpkix-jdk15on:1.59'
        classpath 'commons-io:commons-io:2.5'
        classpath 'commons-codec:commons-codec:1.11'
    }
}


import org.apache.commons.codec.digest.Crypt
import org.apache.commons.io.FileUtils
import org.bouncycastle.asn1.pkcs.PrivateKeyInfo
import org.bouncycastle.asn1.x500.X500Name
import org.bouncycastle.asn1.x500.X500NameBuilder
import org.bouncycastle.asn1.x500.style.BCStyle
import org.bouncycastle.asn1.x509.SubjectPublicKeyInfo
import org.bouncycastle.bcpg.ArmoredOutputStream
import org.bouncycastle.bcpg.HashAlgorithmTags
import org.bouncycastle.bcpg.SymmetricKeyAlgorithmTags
import org.bouncycastle.bcpg.sig.Features
import org.bouncycastle.bcpg.sig.KeyFlags
import org.bouncycastle.cert.X509CertificateHolder
import org.bouncycastle.cert.X509v3CertificateBuilder
import org.bouncycastle.cert.jcajce.JcaX509CertificateConverter
import org.bouncycastle.cert.jcajce.JcaX509v3CertificateBuilder
import org.bouncycastle.crypto.generators.RSAKeyPairGenerator
import org.bouncycastle.crypto.params.RSAKeyGenerationParameters
import org.bouncycastle.jce.provider.BouncyCastleProvider
import org.bouncycastle.openpgp.*
import org.bouncycastle.openpgp.operator.PBESecretKeyEncryptor
import org.bouncycastle.openpgp.operator.PGPDigestCalculator
import org.bouncycastle.openpgp.operator.bc.BcPBESecretKeyEncryptorBuilder
import org.bouncycastle.openpgp.operator.bc.BcPGPContentSignerBuilder
import org.bouncycastle.openpgp.operator.bc.BcPGPDigestCalculatorProvider
import org.bouncycastle.openpgp.operator.bc.BcPGPKeyPair
import org.bouncycastle.openssl.jcajce.JcaPEMWriter
import org.bouncycastle.operator.ContentSigner
import org.bouncycastle.operator.jcajce.JcaContentSignerBuilder
import org.bouncycastle.util.io.pem.PemObject
import org.bouncycastle.util.io.pem.PemWriter

import java.nio.charset.Charset
import java.security.KeyPair
import java.security.KeyPairGenerator
import java.security.SecureRandom
import java.security.Security
import java.security.cert.X509Certificate
import java.time.LocalDate
import java.time.ZoneOffset

def generateRSAKeyPair() {
    KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance("RSA", "BC")
    keyPairGenerator.initialize(2048, new SecureRandom())
    keyPairGenerator.genKeyPair()
}

def createPGPKeyRingGenerator(String userId, char[] passphrase) throws Exception {
    RSAKeyPairGenerator keyPairGenerator = new RSAKeyPairGenerator()

    keyPairGenerator.init(
            new RSAKeyGenerationParameters(
                    BigInteger.valueOf(0x10001),
                    new SecureRandom(),
                    1024,
                    12
            )
    )

    PGPKeyPair rsaKeyPairSign = new BcPGPKeyPair(
            PGPPublicKey.RSA_SIGN,
            keyPairGenerator.generateKeyPair(),
            new Date()
    )

    PGPKeyPair rsaKeyPairEncrypt = new BcPGPKeyPair(
            PGPPublicKey.RSA_ENCRYPT,
            keyPairGenerator.generateKeyPair(),
            new Date()
    )

    PGPSignatureSubpacketGenerator signHashGenerator = new PGPSignatureSubpacketGenerator()
    signHashGenerator.setKeyFlags(false, KeyFlags.SIGN_DATA | KeyFlags.CERTIFY_OTHER)
    signHashGenerator.setFeature(false, Features.FEATURE_MODIFICATION_DETECTION)

    PGPSignatureSubpacketGenerator encryptHashGenerator = new PGPSignatureSubpacketGenerator()
    encryptHashGenerator.setKeyFlags(false, KeyFlags.ENCRYPT_COMMS | KeyFlags.ENCRYPT_STORAGE)

    PGPDigestCalculator sha1DigestCalculator = new BcPGPDigestCalculatorProvider().get(HashAlgorithmTags.SHA1)
    PGPDigestCalculator sha512DigestCalculator = new BcPGPDigestCalculatorProvider().get(HashAlgorithmTags.SHA512)

    PBESecretKeyEncryptor secretKeyEncryptor = (
            new BcPBESecretKeyEncryptorBuilder(PGPEncryptedData.AES_256, sha512DigestCalculator)
    ).build(passphrase)

    PGPKeyRingGenerator keyRingGen = new PGPKeyRingGenerator(
            PGPSignature.NO_CERTIFICATION,
            rsaKeyPairSign,
            userId,
            sha1DigestCalculator,
            signHashGenerator.generate(),
            null,
            new BcPGPContentSignerBuilder(rsaKeyPairSign.getPublicKey().getAlgorithm(), HashAlgorithmTags.SHA512),
            secretKeyEncryptor
    )

    keyRingGen.addSubKey(rsaKeyPairEncrypt, encryptHashGenerator.generate(), null)

    return keyRingGen
}

def armorByteArray(byte[] data) {
    ByteArrayOutputStream encOut = new ByteArrayOutputStream()
    ArmoredOutputStream armorOut = new ArmoredOutputStream(encOut)
    armorOut.write(data)
    armorOut.flush()
    armorOut.close()
    encOut.toByteArray()
}

def generateSSLCertificate() {
    KeyPair keyPair = generateRSAKeyPair()
    X500Name subject = new X500NameBuilder(BCStyle.INSTANCE).addRDN(BCStyle.CN, "keys").build()
    SecureRandom random = new SecureRandom()
    byte[] id = new byte[20]
    random.nextBytes(id)
    BigInteger serial = new BigInteger(160, random)
    X509v3CertificateBuilder certificate = new JcaX509v3CertificateBuilder(
            subject,
            serial,
            Date.from(LocalDate.of(2018, 1, 1).atStartOfDay(ZoneOffset.UTC).toInstant()),
            Date.from(LocalDate.of(2020, 1, 1).atStartOfDay(ZoneOffset.UTC).toInstant()),
            subject,
            keyPair.getPublic())

    ContentSigner signer = new JcaContentSignerBuilder("SHA256withRSA").build(keyPair.getPrivate())
    X509CertificateHolder holder = certificate.build(signer)

    JcaX509CertificateConverter converter = new JcaX509CertificateConverter()
    converter.setProvider(new BouncyCastleProvider())
    X509Certificate x509 = converter.getCertificate(holder)

    new File(".tmp/ssl").mkdirs()
    FileWriter fileWriter = new FileWriter(".tmp/ssl/ssl.cert")
    JcaPEMWriter pemWriter = new JcaPEMWriter(fileWriter)
    pemWriter.writeObject(x509)
    pemWriter.close()

    writePrivateKey(keyPair, ".tmp/ssl/ssl.key")
}

def generatePGPKeyPair(String userId, String passphrase) {
    PGPKeyRingGenerator generator = createPGPKeyRingGenerator(userId, passphrase.toCharArray())

    PGPPublicKeyRing pkr = generator.generatePublicKeyRing()
    ByteArrayOutputStream pubOut = new ByteArrayOutputStream()
    pkr.encode(pubOut)
    pubOut.close()

    PGPSecretKeyRing skr = generator.generateSecretKeyRing()
    ByteArrayOutputStream secOut = new ByteArrayOutputStream()
    skr.encode(secOut)
    secOut.close()

    byte[] armoredPublicBytes = armorByteArray(pubOut.toByteArray())
    byte[] armoredSecretBytes = armorByteArray(secOut.toByteArray())

    new File(".tmp/pgp").mkdirs()
    File pubFile = new File(".tmp/pgp/${userId}.pub")
    FileUtils.write(pubFile, new String(armoredPublicBytes), Charset.defaultCharset())

    File secFile = new File(".tmp/pgp/${userId}.sec")
    FileUtils.write(secFile, new String(armoredSecretBytes), Charset.defaultCharset())
}

def generateUser(String username) {
    KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance("RSA")
    keyPairGenerator.initialize(2048, new SecureRandom())
    KeyPair keyPair = keyPairGenerator.genKeyPair()

    String sshKeyString = "ssh-rsa " + Base64.getEncoder().encodeToString(keyPair.public.encoded)

    String password = UUID.randomUUID().toString().replace("-", "")
    String salt = UUID.randomUUID().toString().replace("-", "")
    String hash = Crypt.crypt(password, "\$1\$${salt}\$")

    File userYML = new File(".tmp/users/${username}.yml")
    FileUtils.writeLines(userYML, Arrays.asList("---", "password_hash: " + hash, "pubkey: " + sshKeyString))
    writePublicKey(keyPair, ".tmp/users/pgp/${username}.pub")
    writePrivateKey(keyPair, ".tmp/users/pgp/${username}.sec")

    return password
}

def writePublicKey(KeyPair keyPair, String path) {
    SubjectPublicKeyInfo spkInfo = SubjectPublicKeyInfo.getInstance(keyPair.public.encoded)
    byte[] publicKeyPKCS1 = spkInfo.parsePublicKey().encoded
    PemObject pemObject = new PemObject("RSA PUBLIC KEY", publicKeyPKCS1)
    StringWriter stringWriter = new StringWriter()
    PemWriter pemWriter = new PemWriter(stringWriter)
    pemWriter.writeObject(pemObject)
    pemWriter.close()
    String publicKeyString = stringWriter.toString()
    File file = new File(path)
    FileUtils.write(file, publicKeyString, Charset.defaultCharset())
}

def writePrivateKey(KeyPair keyPair, String path) {
    PrivateKeyInfo pkInfo = PrivateKeyInfo.getInstance(keyPair.private.encoded)
    byte[] privateKeyPKCS1 = pkInfo.parsePrivateKey().toASN1Primitive().encoded
    PemObject pemObject = new PemObject("RSA PRIVATE KEY", privateKeyPKCS1)
    StringWriter stringWriter = new StringWriter()
    PemWriter pemWriter = new PemWriter(stringWriter)
    pemWriter.writeObject(pemObject)
    pemWriter.close()
    String privateKeyString = stringWriter.toString()
    File file = new File(path)
    FileUtils.write(file, privateKeyString, Charset.defaultCharset())
}

def writeTrace(String key, String value) {
    File traceFile = new File(".tmp/.trace")
    String existingValue = readTrace(traceFile, key)
    if (existingValue == null) {
        FileUtils.writeLines(traceFile, Collections.singleton(String.format("%s=%s", key, value)), true)
    }
}

def readTrace(File traceFile, String key) {
    try {
        List<String> lines = FileUtils.readLines(traceFile, Charset.defaultCharset())
        for (String line : lines) {
            if (line.startsWith(key)) {
                return line.split("=")[1].trim()
            }
        }
        return null
    } catch (FileNotFoundException e) {
        return null
    }
}

def readTrace(String key) {
    File traceFile = new File(".tmp/.trace")
    readTrace(traceFile, key)
}

def getTraceAsMAp() {
    File traceFile = new File(".tmp/.trace")
    List<String> lines = FileUtils.readLines(traceFile, Charset.defaultCharset())
    Map<String, String> result = new HashMap<>()
    for (String line : lines) {
        result.put(line.split("=")[0].trim(), line.split("=")[1].trim())
    }
    result
}

task initBouncyCastle() {
    Security.addProvider(new BouncyCastleProvider())
}