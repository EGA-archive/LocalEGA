buildscript {
    repositories {
        mavenCentral()
        maven {
            url "https://github.com/uio-bmi/crypt4gh/raw/maven"
        }
    }

    dependencies {
        classpath "org.bouncycastle:bcpg-jdk15on:1.59"
        classpath "org.bouncycastle:bcpkix-jdk15on:1.59"
        classpath "commons-io:commons-io:2.5"
        classpath "commons-codec:commons-codec:1.11"
        classpath "com.hierynomus:sshj:0.22.0"
        classpath "com.rabbitmq:amqp-client:5.1.1"
        classpath "no.uio.ifi:crypt4gh:1.0.0"
    }
}

import com.rabbitmq.client.AMQP
import com.rabbitmq.client.Channel
import com.rabbitmq.client.Connection
import com.rabbitmq.client.ConnectionFactory
import net.schmizz.sshj.SSHClient
import net.schmizz.sshj.common.Buffer
import net.schmizz.sshj.sftp.SFTPClient
import net.schmizz.sshj.transport.verification.PromiscuousVerifier
import no.ifi.uio.crypt4gh.stream.Crypt4GHOutputStream
import org.apache.commons.codec.digest.Crypt
import org.apache.commons.codec.digest.DigestUtils
import org.apache.commons.io.FileUtils
import org.bouncycastle.asn1.x500.X500Name
import org.bouncycastle.asn1.x500.X500NameBuilder
import org.bouncycastle.asn1.x500.style.BCStyle
import org.bouncycastle.bcpg.ArmoredOutputStream
import org.bouncycastle.bcpg.HashAlgorithmTags
import org.bouncycastle.bcpg.sig.Features
import org.bouncycastle.bcpg.sig.KeyFlags
import org.bouncycastle.cert.X509CertificateHolder
import org.bouncycastle.cert.X509v3CertificateBuilder
import org.bouncycastle.cert.jcajce.JcaX509CertificateConverter
import org.bouncycastle.cert.jcajce.JcaX509v3CertificateBuilder
import org.bouncycastle.crypto.generators.RSAKeyPairGenerator
import org.bouncycastle.crypto.params.RSAKeyGenerationParameters
import org.bouncycastle.jce.provider.BouncyCastleProvider
import org.bouncycastle.openpgp.*
import org.bouncycastle.openpgp.operator.PBESecretKeyEncryptor
import org.bouncycastle.openpgp.operator.PGPDigestCalculator
import org.bouncycastle.openpgp.operator.bc.BcPBESecretKeyEncryptorBuilder
import org.bouncycastle.openpgp.operator.bc.BcPGPContentSignerBuilder
import org.bouncycastle.openpgp.operator.bc.BcPGPDigestCalculatorProvider
import org.bouncycastle.openpgp.operator.bc.BcPGPKeyPair
import org.bouncycastle.openssl.jcajce.JcaPEMWriter
import org.bouncycastle.operator.ContentSigner
import org.bouncycastle.operator.jcajce.JcaContentSignerBuilder

import java.nio.ByteBuffer
import java.nio.charset.Charset
import java.nio.charset.StandardCharsets
import java.nio.file.Files
import java.nio.file.attribute.PosixFilePermission
import java.security.KeyPair
import java.security.KeyPairGenerator
import java.security.SecureRandom
import java.security.Security
import java.security.cert.X509Certificate
import java.time.LocalDate
import java.time.ZoneOffset

Security.addProvider(new BouncyCastleProvider())

def generateCEGAMQConfiguration() {
    File rabbitmqConfig = new File("${project.projectDir.toString()}/.tmp/mq/rabbitmq.config")
    FileUtils.write(rabbitmqConfig, "%% -*- mode: erlang -*-\n" +
            "%%\n" +
            "[{rabbit,[{loopback_users, [ ] },\n" +
            "\t  {disk_free_limit, \"1GB\"}]},\n" +
            " {rabbitmq_management, [ {load_definitions, \"/etc/rabbitmq/defs.json\"} ]}\n" +
            "].", Charset.defaultCharset())

    byte[] saltBytes = new byte[4]
    new SecureRandom().nextBytes(saltBytes)
    String password = UUID.randomUUID().toString().replace("-", "")
    byte[] passwordBytes = password.getBytes()
    byte[] concat = ByteBuffer.allocate(saltBytes.length + passwordBytes.length).put(saltBytes).put(passwordBytes).array()
    byte[] hash = DigestUtils.sha256(concat)
    concat = ByteBuffer.allocate(saltBytes.length + hash.length).put(saltBytes).put(hash).array()
    String saltedHash = Base64.getEncoder().encodeToString(concat)

    mkdir "${project.projectDir.toString()}/.tmp/mq"
    File defsJSON = new File("${project.projectDir.toString()}/.tmp/mq/defs.json")
    FileUtils.write(defsJSON, "{\"rabbit_version\":\"3.6.11\",\n" +
            " \"users\":[{\"name\":\"lega\",\"password_hash\":\"${saltedHash}\",\"hashing_algorithm\":\"rabbit_password_hashing_sha256\",\"tags\":\"administrator\"}],\n" +
            " \"vhosts\":[{\"name\":\"lega\"}],\n" +
            " \"permissions\":[{\"user\":\"lega\", \"vhost\":\"lega\", \"configure\":\".*\", \"write\":\".*\", \"read\":\".*\"}],\n" +
            " \"parameters\":[],\n" +
            " \"global_parameters\":[{\"name\":\"cluster_name\", \"value\":\"rabbit@localhost\"}],\n" +
            " \"policies\":[],\n" +
            " \"queues\":[{\"name\":\"inbox\",           \"vhost\":\"lega\", \"durable\":true, \"auto_delete\":false, \"arguments\":{}},\n" +
            "           {\"name\":\"inbox.checksums\", \"vhost\":\"lega\", \"durable\":true, \"auto_delete\":false, \"arguments\":{}},\n" +
            "\t   {\"name\":\"files\",           \"vhost\":\"lega\", \"durable\":true, \"auto_delete\":false, \"arguments\":{}},\n" +
            "\t   {\"name\":\"completed\",       \"vhost\":\"lega\", \"durable\":true, \"auto_delete\":false, \"arguments\":{}},\n" +
            "\t   {\"name\":\"errors\",          \"vhost\":\"lega\", \"durable\":true, \"auto_delete\":false, \"arguments\":{}}],\n" +
            " \"exchanges\":[{\"name\":\"localega.v1\", \"vhost\":\"lega\", \"type\":\"topic\", \"durable\":true, \"auto_delete\":false, \"internal\":false, \"arguments\":{}}],\n" +
            " \"bindings\":[{\"source\":\"localega.v1\",\"vhost\":\"lega\",\"destination_type\":\"queue\",\"arguments\":{},\"destination\":\"inbox\",\"routing_key\":\"files.inbox\"},\n" +
            "\t     {\"source\":\"localega.v1\",\"vhost\":\"lega\",\"destination_type\":\"queue\",\"arguments\":{},\"destination\":\"inbox.checksums\",\"routing_key\":\"files.inbox.checksums\"},\n" +
            "\t     {\"source\":\"localega.v1\",\"vhost\":\"lega\",\"destination_type\":\"queue\",\"arguments\":{},\"destination\":\"files\",\"routing_key\":\"files\"},\n" +
            "\t     {\"source\":\"localega.v1\",\"vhost\":\"lega\",\"destination_type\":\"queue\",\"arguments\":{},\"destination\":\"completed\",\"routing_key\":\"files.completed\"},\n" +
            "\t     {\"source\":\"localega.v1\",\"vhost\":\"lega\",\"destination_type\":\"queue\",\"arguments\":{},\"destination\":\"errors\",\"routing_key\":\"files.error\"}]\n" +
            "}", Charset.defaultCharset())
    password
}

def generateUser(String username) {
    KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance("RSA")
    keyPairGenerator.initialize(2048, new SecureRandom())
    KeyPair keyPair = keyPairGenerator.genKeyPair()

    byte[] keyBytes = new Buffer.PlainBuffer().putPublicKey(keyPair.public).compactData
    String sshKeyString = "ssh-rsa " + Base64.getEncoder().encodeToString(keyBytes)

    String password = UUID.randomUUID().toString().replace("-", "")
    String salt = UUID.randomUUID().toString().replace("-", "")
    String hash = Crypt.crypt(password, "\$1\$${salt}\$")

    File userYML = new File("${project.projectDir.toString()}/.tmp/users/${username}.yml")
    FileUtils.writeLines(userYML, Arrays.asList("---", "password_hash: " + hash, "pubkey: " + sshKeyString))
    writePublicKey(keyPair, "${project.projectDir.toString()}/.tmp/users/${username}.pub")
    writePrivateKey(keyPair, "${project.projectDir.toString()}/.tmp/users/${username}.sec")

    return password
}

def writeTrace(String key, String value) {
    File traceFile = new File("${project.projectDir.toString()}/.tmp/.trace")
    String existingValue = readTrace(traceFile, key)
    if (existingValue == null) {
        FileUtils.writeLines(traceFile, Collections.singleton(String.format("%s=%s", key, value)), true)
    }
}

def readTrace(File traceFile, String key) {
    try {
        List<String> lines = FileUtils.readLines(traceFile, Charset.defaultCharset())
        for (String line : lines) {
            if (line.startsWith(key)) {
                return line.split("=")[1].trim()
            }
        }
        return null
    } catch (FileNotFoundException e) {
        return null
    }
}

def readTrace(String key) {
    File traceFile = new File("${project.projectDir.toString()}/.tmp/.trace")
    readTrace(traceFile, key)
}

def generateRSAKeyPair() {
    KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance("RSA", "BC")
    keyPairGenerator.initialize(2048, new SecureRandom())
    keyPairGenerator.genKeyPair()
}

def createPGPKeyRingGenerator(String userId, char[] passphrase) throws Exception {
    RSAKeyPairGenerator keyPairGenerator = new RSAKeyPairGenerator()

    keyPairGenerator.init(
            new RSAKeyGenerationParameters(
                    BigInteger.valueOf(0x10001),
                    new SecureRandom(),
                    1024,
                    12
            )
    )

    PGPKeyPair rsaKeyPairSign = new BcPGPKeyPair(
            PGPPublicKey.RSA_SIGN,
            keyPairGenerator.generateKeyPair(),
            new Date()
    )

    PGPKeyPair rsaKeyPairEncrypt = new BcPGPKeyPair(
            PGPPublicKey.RSA_ENCRYPT,
            keyPairGenerator.generateKeyPair(),
            new Date()
    )

    PGPSignatureSubpacketGenerator signHashGenerator = new PGPSignatureSubpacketGenerator()
    signHashGenerator.setKeyFlags(false, KeyFlags.SIGN_DATA | KeyFlags.CERTIFY_OTHER)
    signHashGenerator.setFeature(false, Features.FEATURE_MODIFICATION_DETECTION)

    PGPSignatureSubpacketGenerator encryptHashGenerator = new PGPSignatureSubpacketGenerator()
    encryptHashGenerator.setKeyFlags(false, KeyFlags.ENCRYPT_COMMS | KeyFlags.ENCRYPT_STORAGE)

    PGPDigestCalculator sha1DigestCalculator = new BcPGPDigestCalculatorProvider().get(HashAlgorithmTags.SHA1)
    PGPDigestCalculator sha512DigestCalculator = new BcPGPDigestCalculatorProvider().get(HashAlgorithmTags.SHA512)

    PBESecretKeyEncryptor secretKeyEncryptor = (
            new BcPBESecretKeyEncryptorBuilder(PGPEncryptedData.AES_256, sha512DigestCalculator)
    ).build(passphrase)

    PGPKeyRingGenerator keyRingGen = new PGPKeyRingGenerator(
            PGPSignature.NO_CERTIFICATION,
            rsaKeyPairSign,
            userId,
            sha1DigestCalculator,
            signHashGenerator.generate(),
            null,
            new BcPGPContentSignerBuilder(rsaKeyPairSign.getPublicKey().getAlgorithm(), HashAlgorithmTags.SHA512),
            secretKeyEncryptor
    )

    keyRingGen.addSubKey(rsaKeyPairEncrypt, encryptHashGenerator.generate(), null)

    return keyRingGen
}

def armorByteArray(byte[] data) {
    ByteArrayOutputStream encOut = new ByteArrayOutputStream()
    ArmoredOutputStream armorOut = new ArmoredOutputStream(encOut)
    armorOut.write(data)
    armorOut.flush()
    armorOut.close()
    encOut.toByteArray()
}

def writePublicKey(KeyPair keyPair, String path) {
    File file = new File(path)
    FileWriter fileWriter = new FileWriter(file)
    JcaPEMWriter pemWriter = new JcaPEMWriter(fileWriter)
    pemWriter.writeObject(keyPair.public)
    pemWriter.close()
}

def writePrivateKey(KeyPair keyPair, String path) {
    File file = new File(path)
    FileWriter fileWriter = new FileWriter(file)
    JcaPEMWriter pemWriter = new JcaPEMWriter(fileWriter)
    pemWriter.writeObject(keyPair.private)
    pemWriter.close()
    Set<PosixFilePermission> perms = new HashSet<>()
    perms.add(PosixFilePermission.OWNER_READ)
    Files.setPosixFilePermissions(file.toPath(), perms)
}

def generateSSLCertificate() {
    KeyPair keyPair = generateRSAKeyPair()
    X500Name subject = new X500NameBuilder(BCStyle.INSTANCE).addRDN(BCStyle.CN, "keys").build()
    SecureRandom random = new SecureRandom()
    byte[] id = new byte[20]
    random.nextBytes(id)
    BigInteger serial = new BigInteger(160, random)
    X509v3CertificateBuilder certificate = new JcaX509v3CertificateBuilder(
            subject,
            serial,
            Date.from(LocalDate.of(2018, 1, 1).atStartOfDay(ZoneOffset.UTC).toInstant()),
            Date.from(LocalDate.of(2020, 1, 1).atStartOfDay(ZoneOffset.UTC).toInstant()),
            subject,
            keyPair.getPublic())

    ContentSigner signer = new JcaContentSignerBuilder("SHA256withRSA").build(keyPair.getPrivate())
    X509CertificateHolder holder = certificate.build(signer)

    JcaX509CertificateConverter converter = new JcaX509CertificateConverter()
    converter.setProvider(new BouncyCastleProvider())
    X509Certificate x509 = converter.getCertificate(holder)

    new File("${project.projectDir.toString()}/.tmp/ssl").mkdirs()
    FileWriter fileWriter = new FileWriter("${project.projectDir.toString()}/.tmp/ssl/ssl.cert")
    JcaPEMWriter pemWriter = new JcaPEMWriter(fileWriter)
    pemWriter.writeObject(x509)
    pemWriter.close()

    writePrivateKey(keyPair, "${project.projectDir.toString()}/.tmp/ssl/ssl.key")
}

def generatePGPKeyPair(String userId, String passphrase) {
    PGPKeyRingGenerator generator = createPGPKeyRingGenerator(userId, passphrase.toCharArray())

    PGPPublicKeyRing pkr = generator.generatePublicKeyRing()
    ByteArrayOutputStream pubOut = new ByteArrayOutputStream()
    pkr.encode(pubOut)
    pubOut.close()

    PGPSecretKeyRing skr = generator.generateSecretKeyRing()
    ByteArrayOutputStream secOut = new ByteArrayOutputStream()
    skr.encode(secOut)
    secOut.close()

    byte[] armoredPublicBytes = armorByteArray(pubOut.toByteArray())
    byte[] armoredSecretBytes = armorByteArray(secOut.toByteArray())

    new File("${project.projectDir.toString()}/.tmp/pgp").mkdirs()
    File pubFile = new File("${project.projectDir.toString()}/.tmp/pgp/${userId}.pub")
    FileUtils.write(pubFile, new String(armoredPublicBytes), Charset.defaultCharset())

    File secFile = new File("${project.projectDir.toString()}/.tmp/pgp/${userId}.sec")
    FileUtils.write(secFile, new String(armoredSecretBytes), Charset.defaultCharset())
    Set<PosixFilePermission> perms = new HashSet<>()
    perms.add(PosixFilePermission.OWNER_READ)
    Files.setPosixFilePermissions(secFile.toPath(), perms)
}

def generateConfIni() {
    File confIni = new File("${project.projectDir.toString()}/.tmp/conf.ini")
    FileUtils.write(confIni, "[DEFAULT]\n" +
            "log = console\n" +
            "\n" +
            "[keyserver]\n" +
            "port = 8443\n" +
            "\n" +
            "[quality_control]\n" +
            "keyserver_endpoint = https://keys:8443/retrieve/%s/private\n" +
            "\n" +
            "[inbox]\n" +
            "location = /ega/inbox/%s\n" +
            "mode = 2750\n" +
            "\n" +
            "[vault]\n" +
            "driver = S3Storage\n" +
            "url = http://s3:9000\n" +
            "access_key = ${readTrace("S3_ACCESS_KEY")}\n" +
            "secret_key = ${readTrace("S3_SECRET_KEY")}\n" +
            "#region = lega\n" +
            "\n" +
            "\n" +
            "[outgestion]\n" +
            "# Just for test\n" +
            "keyserver_endpoint = https://keys:8443/retrieve/%s/private\n" +
            "\n" +
            "## Connecting to Local EGA\n" +
            "[broker]\n" +
            "host = mq\n" +
            "connection_attempts = 30\n" +
            "# delay in seconds\n" +
            "retry_delay = 10\n" +
            "\n" +
            "[postgres]\n" +
            "host = ${readTrace("DB_INSTANCE")}\n" +
            "user = ${readTrace("POSTGRES_USER")}\n" +
            "password = ${readTrace("POSTGRES_PASSWORD")}\n" +
            "try = 30\n" +
            "\n" +
            "[eureka]\n" +
            "endpoint = http://cega-eureka:8761", Charset.defaultCharset())
}

def generateKeysIni() {
    File keysIni = new File("${project.projectDir.toString()}/.tmp/keys.ini")
    FileUtils.write(keysIni, "[DEFAULT]\n" +
            "active : key.1\n" +
            "\n" +
            "[key.1]\n" +
            "path : /etc/ega/pgp/ega.sec\n" +
            "passphrase : ${readTrace("PGP_PASSPHRASE")}\n" +
            "expire: 30/MAR/19 08:00:00\n" +
            "\n" +
            "[key.2]\n" +
            "path : /etc/ega/pgp/ega2.sec\n" +
            "passphrase : ${readTrace("PGP_PASSPHRASE")}\n" +
            "expire: 30/MAR/18 08:00:00", Charset.defaultCharset())
}

def getTraceAsMAp() {
    File traceFile = new File("${project.projectDir.toString()}/.tmp/.trace")
    List<String> lines = FileUtils.readLines(traceFile, Charset.defaultCharset())
    Map<String, String> result = new HashMap<>()
    for (String line : lines) {
        result.put(line.split("=")[0].trim(), line.split("=")[1].trim())
    }
    result
}

private void generateFile() {
    mkdir ".tmp"
    File rawFile = new File(".tmp/data.raw")
    RandomAccessFile randomAccessFile = new RandomAccessFile(rawFile, "rw")
    randomAccessFile.setLength(1024 * 1024 * 10)
    randomAccessFile.close()
}

private void encryptFile() {
    File rawFile = new File(".tmp/data.raw")
    File encryptedFile = new File(".tmp/data.raw.enc")
    byte[] digest = DigestUtils.sha256(FileUtils.openInputStream(rawFile))
    String key = FileUtils.readFileToString(new File("lega/.tmp/pgp/ega.pub"), Charset.defaultCharset())
    FileOutputStream fileOutputStream = new FileOutputStream(encryptedFile)
    Crypt4GHOutputStream crypt4GHOutputStream = new Crypt4GHOutputStream(fileOutputStream, key, digest)
    FileUtils.copyFile(rawFile, crypt4GHOutputStream)
    crypt4GHOutputStream.close()
}

private void uploadFile() {
    SSHClient ssh = new SSHClient()
    ssh.addHostKeyVerifier(new PromiscuousVerifier())
    ssh.connect("localhost", 2222)
    ssh.authPublickey("john", "cega/.tmp/users/john.sec")
    SFTPClient client = ssh.newSFTPClient()
    client.put(".tmp/data.raw.enc", "data.raw.enc")
    ssh.close()
}

private void ingestFile() {
    ConnectionFactory factory = new ConnectionFactory()
    String mqPassword = readTrace(new File("cega/.tmp/.trace"), "CEGA_MQ_PASSWORD")
    factory.setUri("amqp://lega:${mqPassword}@localhost:5672/lega")
    Connection connectionFactory = factory.newConnection()
    Channel channel = connectionFactory.createChannel()
    AMQP.BasicProperties properties = new AMQP.BasicProperties().builder().
            deliveryMode(2).
            contentType("application/json").
            contentEncoding(StandardCharsets.UTF_8.displayName()).
            build()


    String stableId = "EGAF" + UUID.randomUUID().toString().replace("-", "")
    channel.basicPublish("localega.v1",
            "files",
            properties,
            "{\"user\":\"john\",\"filepath\":\"data.raw.enc\",\"stable_id\":\"${stableId}\"}".bytes)

    channel.close()
    connectionFactory.close()
}

ext {
    generateSSLCertificate = this.&generateSSLCertificate
    generatePGPKeyPair = this.&generatePGPKeyPair
    generateConfIni = this.&generateConfIni
    generateKeysIni = this.&generateKeysIni
    generateCEGAMQConfiguration = this.&generateCEGAMQConfiguration
    generateUser = this.&generateUser
    writeTrace = this.&writeTrace
    readTrace = this.&readTrace
    getTraceAsMAp = this.&getTraceAsMAp
    generateFile = this.&generateFile
    encryptFile = this.&encryptFile
    uploadFile = this.&uploadFile
    ingestFile = this.&ingestFile
}